# -*- coding: utf-8 -*-
"""
Bot Telegram - v13.15 (ƒë·ªìng b·ªô)
- X√°c th·ª±c key b·∫Øt bu·ªôc tr∆∞·ªõc khi d√πng c√°c l·ªánh kh√°c.
- L∆∞u user ƒë√£ x√°c th·ª±c v√†o Json/authorized_users.json (t·ªìn t·∫°i qua l·∫ßn ch·∫°y sau).
- H·ªó tr·ª£ ch·ªçn t∆∞·ªõng/skin theo list.txt v·ªõi ph√¢n trang.
- C√≥ s·∫µn c√°c l·ªánh: /start, /key, /checkkey, /choosehero, /run, /block, /unblock, /sendfiles, /newkey
"""

import warnings
warnings.filterwarnings("ignore")
import threading
import os
import sys
import json
import math
import shutil
import random
import subprocess
from io import BytesIO
from datetime import datetime, timedelta
from uuid import uuid4
from urllib.parse import quote_plus
import re 
import base64
import requests
import time
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.ext import (
    Updater, CommandHandler, CallbackQueryHandler,
    CallbackContext, MessageHandler, Filters, ConversationHandler
)

# ========================= C·∫•u h√¨nh =========================
TOKEN = "8089667166:AAEwvBDYbSUXwtQTZ9pq1fnJFpxY5KT6yR8"  # <--- ƒê·ªîI TOKEN BOT ·ªû ƒê√ÇY
ADMIN_ID = -1002318400679            # <--- ƒê·ªîI TH√ÄNH user_id Telegram c·ªßa b·∫°n (s·ªë d∆∞∆°ng), kh√¥ng ph·∫£i ID k√™nh/nh√≥m

# Th∆∞ m·ª•c/Files
JSON_DIR = "Json"
os.makedirs(JSON_DIR, exist_ok=True)

FILE_USERS        = os.path.join(JSON_DIR, "users.json")
FILE_BLOCKED      = os.path.join(JSON_DIR, "blocked_users.json")
FILE_KEYS_DB      = os.path.join(JSON_DIR, "key.json")               # n·∫øu b·∫°n mu·ªën t·ª± qu·∫£n l√Ω key h·∫øt h·∫°n th·ªß c√¥ng
FILE_AUTHORIZED   = os.path.join(JSON_DIR, "authorized_users.json")   # danh s√°ch user_id ƒë√£ x√°c th·ª±c key

# File danh s√°ch t∆∞·ªõng/skin
FILE_LIST = "list.txt"

# C·∫•u h√¨nh kh√°c
ITEMS_PER_PAGE = 18  # 4 c·ªôt √ó 4 h√†ng = 18 item m·ªói trang
HSD = datetime(2025, 10, 19)  # h·∫°n d√πng tool free-key (n·∫øu mu·ªën t·∫Øt sau ng√†y n√†y)

# ======================= Bi·∫øn to√†n c·ª•c ======================
heroes = {}  # { "Tulen": [("1","Skin A"), ("2","Skin B")], ... }

# ============================================================
#                    TI·ªÜN √çCH JSON
# ============================================================
def load_json(file_path, default):
    if os.path.isfile(file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return default
    return default

def save_json(file_path, data):
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

# T·∫≠p h·ª£p user ƒë√£ x√°c th·ª±c (ƒë·ªÉ ki·ªÉm nhanh)
def load_authorized_users():
    lst = load_json(FILE_AUTHORIZED, [])
    # ƒë·∫£m b·∫£o l√† set c√°c int
    s = set()
    for x in lst:
        try:
            s.add(int(x))
        except:
            pass
    return s

def save_authorized_users(users_set):
    save_json(FILE_AUTHORIZED, list(map(int, users_set)))

AUTHORIZED_USERS = load_authorized_users()

def is_blocked(user):
    blocked = load_json(FILE_BLOCKED, {})
    uid = str(user.id)
    uname = f"@{user.username}" if user.username else None
    return (uid in blocked) or (uname and uname in blocked)

def ensure_authorized(update: Update) -> bool:
    """Ki·ªÉm tra ƒë√£ x√°c th·ª±c key ch∆∞a. N·∫øu ch∆∞a, nh·∫Øc d√πng /key."""
    user = update.effective_user
    if user is None:
        return False
    if int(user.id) in AUTHORIZED_USERS or int(user.id) == ADMIN_ID:
        return True
    update.message.reply_text("üîí B·∫°n ch∆∞a x√°c th·ª±c key. D√πng l·ªánh /key ƒë·ªÉ l·∫•y v√† nh·∫≠p key tr∆∞·ªõc.")
    return False

# ============================================================
#                ƒê·ªåC DANH S√ÅCH T∆Ø·ªöNG/SKIN T·ª™ FILE
# ============================================================
def load_heroes_from_list():
    """
    ƒê·ªãnh d·∫°ng FILE_LIST:
    Tulen (Ph√°p s∆∞)
    1 Skin A
    2 Skin B

    Violet (X·∫° th·ªß)
    101 Skin X
    102 Skin Y
    """
    global heroes
    heroes.clear()
    current_hero = None
    if not os.path.isfile(FILE_LIST):
        return
    with open(FILE_LIST, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line:
                continue
            # D√≤ng c√≥ '(' xem nh∆∞ t√™n t∆∞·ªõng
            if "(" in line:
                current_hero = line.split("(")[0].strip()
                heroes[current_hero] = []
                continue
            # C√≤n l·∫°i l√† skin: "<id> <name>"
            if current_hero:
                parts = line.split(maxsplit=1)
                if len(parts) == 2 and parts[0].isdigit():
                    skin_id = parts[0]
                    skin_name = parts[1]
                    heroes[current_hero].append((skin_id, skin_name))

# ============================================================
#                 X√ÇY INLINE KEYBOARD PH√ÇN TRANG
# ============================================================
def build_keyboard(items, type_key, page=0, extra_back=False, user_data=None):
    if user_data is None:
        user_data = {}

    # L∆∞u map callback ri√™ng theo user (ƒë∆°n gi·∫£n ho√° b·∫±ng text tr·ª±c ti·∫øp)
    keyboard = []
    start = page * ITEMS_PER_PAGE
    end = start + ITEMS_PER_PAGE
    page_items = items[start:end]

    row = []
    for item in page_items:
        if type_key == "hero":
            btn_text = item
            cb_data = f"pick_hero::{item}"
        else:
            # item = (skin_id, skin_name)
            btn_text = item[1]
            cb_data = f"pick_skin::{item[0]}::{item[1]}"
        row.append(InlineKeyboardButton(btn_text, callback_data=cb_data))
        if len(row) == 4:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)

    total_pages = max(1, math.ceil(len(items) / ITEMS_PER_PAGE))
    nav_row = []
    if page > 0:
        nav_row.append(InlineKeyboardButton("‚¨ÖÔ∏è Tr∆∞·ªõc", callback_data=f"page::{type_key}::{page-1}"))
    if page < total_pages - 1:
        nav_row.append(InlineKeyboardButton("Ti·∫øp ‚û°Ô∏è", callback_data=f"page::{type_key}::{page+1}"))
    if nav_row:
        keyboard.append(nav_row)

    if extra_back:
        keyboard.append([InlineKeyboardButton("‚¨Ö Quay l·∫°i", callback_data="back_main")])

    return InlineKeyboardMarkup(keyboard)

# ============================================================
#                 FREE KEY (T·∫†O & KI·ªÇM TRA)
# ============================================================
def encrypt_data(data):
    return base64.b64encode(data.encode()).decode()

def decrypt_data(encrypted_data):
    return base64.b64decode(encrypted_data.encode()).decode()

def luu_thong_tin_key_session(user_id, key, expiration_date):
    """L∆∞u key t·∫°m (24h) ‚Äì theo user_id, d√πng cho flow free-key."""
    session_file = os.path.join(JSON_DIR, "ip_key.json")
    data = {}
    if os.path.exists(session_file):
        try:
            with open(session_file, "r", encoding="utf-8") as f:
                enc = f.read().strip()
                if enc:
                    data = json.loads(decrypt_data(enc))
        except:
            data = {}
    data[str(user_id)] = {'key': key, 'expiration_date': expiration_date.isoformat()}
    with open(session_file, "w", encoding="utf-8") as f:
        f.write(encrypt_data(json.dumps(data)))

def tai_thong_tin_key_session():
    session_file = os.path.join(JSON_DIR, "ip_key.json")
    try:
        if not os.path.exists(session_file):
            return {}
        file_mtime = datetime.fromtimestamp(os.path.getmtime(session_file))
        if datetime.now() - file_mtime > timedelta(hours=24):
            os.remove(session_file)
            return {}
        with open(session_file, "r", encoding="utf-8") as f:
            enc = f.read().strip()
        if not enc:
            return {}
        return json.loads(decrypt_data(enc))
    except:
        return {}

def kiem_tra_key_session(user_id):
    data = tai_thong_tin_key_session()
    info = data.get(str(user_id))
    if not info:
        return None
    try:
        exp = datetime.fromisoformat(info['expiration_date'])
        if exp > datetime.now():
            return info['key']
    except:
        return None
    return None

def generate_key_and_url(user_id):
    ngay = int(datetime.now().day)
    key1 = str(ngay * 27 + 27)
    random_part = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=6))
    key = f'FreeKey-{key1}{random_part}'
    expiration_date = datetime.now().replace(hour=23, minute=59, second=0, microsecond=0)
    url = f'https://www.webkey.x10.mx/?ma={key}'
    return url, key, expiration_date

def shorten_link(url, max_retries=5):
    """Lu√¥n c·ªë g·∫Øng tr·∫£ v·ªÅ link r√∫t g·ªçn; th·ª≠ t·ªëi ƒëa max_retries l·∫ßn."""
    token = "67cfdd9135fa313c8c20c795" 
    encoded_url = quote_plus(url)
    api_url = f"https://link2m.net/api-shorten/v2?api={token}&url={encoded_url}"
    for _ in range(max_retries):
        try:
            r = requests.get(api_url, timeout=5)
            if r.status_code == 200:
                data = r.json()
                short_url = data.get('shortenedUrl')
                if data.get('status') == 'success' and short_url and short_url.startswith("http"):
                    return short_url
        except:
            pass
        time.sleep(1) 
    raise RuntimeError("Kh√¥ng th·ªÉ t·∫°o link r√∫t g·ªçn sau nhi·ªÅu l·∫ßn th·ª≠.")

KEY_WAITING = 1

def key_command(update: Update, context: CallbackContext):
    """B·∫Øt ƒë·∫ßu flow l·∫•y key (free-key)."""
    user = update.effective_user
    if datetime.now() > HSD:
        update.message.reply_text("‚ùå Tool ƒë√£ h·∫øt h·∫°n s·ª≠ d·ª•ng.")
        return ConversationHandler.END

    # N·∫øu user ƒë√£ x√°c th·ª±c r·ªìi
    if int(user.id) in AUTHORIZED_USERS or int(user.id) == ADMIN_ID:
        update.message.reply_text(" B·∫°n ƒë√£ x√°c th·ª±c r·ªìi, d√πng /start ƒë·ªÉ ti·∫øp t·ª•c.")
        return ConversationHandler.END

    # N·∫øu user ƒë√£ l·∫•y key cho h√¥m nay, cho d√πng l·∫°i
    existing_key = kiem_tra_key_session(user.id)
    if existing_key:
        update.message.reply_text(
            f"üîë Key c·ªßa b·∫°n h√¥m nay: {existing_key}\n"
            f"üëâ G√µ l·∫°i **key** n√†y ƒë·ªÉ x√°c th·ª±c.",
            parse_mode="Markdown"
        )
        context.user_data['expected_key'] = existing_key
        return KEY_WAITING

    # T·∫°o key & link r√∫t g·ªçn
    url, key, expiration_date = generate_key_and_url(user.id)
    short_link = shorten_link(url)

    context.user_data['expected_key'] = key
    context.user_data['expiration_date'] = expiration_date

    update.message.reply_text(
        "üîê *X√ÅC TH·ª∞C KEY*\n"
        f"1) Nh·∫•n v√†o link ƒë·ªÉ l·∫•y key: {short_link}\n"
        "2) Sao ch√©p key v√† g·ª≠i v√†o ƒë√¢y.",
        parse_mode="Markdown"
    )
    return KEY_WAITING

def key_input(update: Update, context: CallbackContext):
    """Nh·∫≠n chu·ªói user nh·∫≠p ‚Äì ki·ªÉm tra v·ªõi expected_key."""
    user = update.effective_user
    text = update.message.text.strip()
    expected = context.user_data.get('expected_key')
    exp_date = context.user_data.get('expiration_date', datetime.now().replace(hour=23, minute=59, second=0, microsecond=0))

    if not expected:
        update.message.reply_text("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu key tr∆∞·ªõc ƒë√≥. G√µ /key ƒë·ªÉ l·∫•y key m·ªõi.")
        return ConversationHandler.END

    if text == expected:
        # L∆∞u session key (ƒë·ªÉ n·∫øu user g·ªçi /key l·∫°i trong 24h v·∫´n c√≥)
        luu_thong_tin_key_session(user.id, expected, exp_date)
        # Th√™m user v√†o danh s√°ch ƒë√£ x√°c th·ª±c l√¢u d√†i
        AUTHORIZED_USERS.add(int(user.id))
        save_authorized_users(AUTHORIZED_USERS)
        update.message.reply_text(" Key ƒë√∫ng! B·∫°n ƒë√£ ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng bot.\nD√πng /start ƒë·ªÉ b·∫Øt ƒë·∫ßu.")
        return ConversationHandler.END
    else:
        update.message.reply_text(" Key sai, vui l√≤ng nh·∫≠p l·∫°i (ho·∫∑c /key ƒë·ªÉ l·∫•y l·∫°i key).")
        return KEY_WAITING

def key_cancel(update: Update, context: CallbackContext):
    update.message.reply_text("ƒê√£ hu·ª∑ nh·∫≠p key.")
    return ConversationHandler.END

# ============================================================
#                    C√ÅC L·ªÜNH QU·∫¢N TR·ªä
# ============================================================
def block_user(update: Update, context: CallbackContext):
    user = update.effective_user
    if int(user.id) != ADMIN_ID:
        update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    if not context.args:
        update.message.reply_text("‚ùó D√πng: /block <user_id ho·∫∑c @username>")
        return
    identifier = context.args[0]
    blocked = load_json(FILE_BLOCKED, {})
    if identifier in blocked:
        update.message.reply_text(f"{identifier} ƒë√£ b·ªã block r·ªìi.")
        return
    blocked[identifier] = True
    save_json(FILE_BLOCKED, blocked)
    update.message.reply_text(f"‚úÖ ƒê√£ block {identifier} th√†nh c√¥ng.")

def unblock_user(update: Update, context: CallbackContext):
    user = update.effective_user
    if int(user.id) != ADMIN_ID:
        update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    if not context.args:
        update.message.reply_text("‚ùó D√πng: /unblock <user_id ho·∫∑c @username>")
        return
    identifier = context.args[0]
    blocked = load_json(FILE_BLOCKED, {})
    if identifier not in blocked:
        update.message.reply_text(f"{identifier} kh√¥ng n·∫±m trong danh s√°ch block.")
        return
    blocked.pop(identifier, None)
    save_json(FILE_BLOCKED, blocked)
    update.message.reply_text(f"‚úÖ ƒê√£ b·ªè block {identifier} th√†nh c√¥ng.")

def send_files(update: Update, context: CallbackContext):
    user = update.effective_user
    if int(user.id) != ADMIN_ID:
        update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    try:
        update.message.reply_text("üì§ ƒêang g·ª≠i file...")
        # G·ª≠i c√°c file JSON ch√≠nh
        for path in [FILE_USERS, FILE_BLOCKED, FILE_KEYS_DB, FILE_AUTHORIZED]:
            if os.path.isfile(path):
                with open(path, "rb") as f:
                    context.bot.send_document(chat_id=ADMIN_ID, document=InputFile(f), filename=os.path.basename(path))
        update.message.reply_text("‚úÖ ƒê√£ g·ª≠i file cho admin.")
    except Exception as e:
        update.message.reply_text(f"‚ùå L·ªói khi g·ª≠i file: {e}")

# T·∫°o key th·ªß c√¥ng (n·∫øu b·∫°n v·∫´n mu·ªën c√≥ kho key h·∫øt h·∫°n ri√™ng)
def newkey(update: Update, context: CallbackContext):
    user = update.effective_user
    if int(user.id) != ADMIN_ID:
        update.message.reply_text("üö´ B·∫°n Kh√¥ng C√≥ Quy·ªÅn T·∫°o Key.")
        return
    args = context.args
    if len(args) != 1:
        update.message.reply_text("üìå D√πng: /newkey <s·ªë_ng√†y>\nV√≠ d·ª•: /newkey 7")
        return
    try:
        days = int(args[0])
        if days <= 0:
            raise ValueError()
    except:
        update.message.reply_text("‚ùó Vui l√≤ng nh·∫≠p s·ªë ng√†y h·ª£p l·ªá (>= 1).")
        return
    keydb = load_json(FILE_KEYS_DB, {})
    new_key = "MMN_" + str(uuid4()).replace("-", "")[:8].upper()
    expired_date = (datetime.now() + timedelta(days=days)).replace(hour=23, minute=59, second=0, microsecond=0).isoformat()
    keydb[new_key] = {"expired": expired_date}
    save_json(FILE_KEYS_DB, keydb)
    update.message.reply_text(f"‚úÖ Key M·ªõi:\nüîë `{new_key}`\nüïí H·∫øt H·∫°n: {expired_date}", parse_mode="Markdown")

def checkkey(update: Update, context: CallbackContext):
    """Ch·ªâ ki·ªÉm tra tr·∫°ng th√°i ƒë√£ x√°c th·ª±c hay ch∆∞a (kh√¥ng d√πng kho key th·ªß c√¥ng)."""
    user = update.effective_user
    if int(user.id) in AUTHORIZED_USERS or int(user.id) == ADMIN_ID:
        update.message.reply_text("‚úÖ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ x√°c th·ª±c key.")
    else:
        update.message.reply_text("üîí B·∫°n CH∆ØA x√°c th·ª±c. D√πng /key ƒë·ªÉ l·∫•y & nh·∫≠p key.")

# ============================================================
#                       L·ªÜNH NG∆Ø·ªúI D√ôNG
# ============================================================
def start(update: Update, context: CallbackContext):
    user = update.effective_user
    if is_blocked(user):
        update.message.reply_text("üö´ B·∫°n ƒë√£ b·ªã ch·∫∑n kh·ªèi vi·ªác s·ª≠ d·ª•ng bot.")
        return
    if not ensure_authorized(update):
        return

    load_heroes_from_list()
    full_name = f"{user.first_name} {user.last_name or ''}".strip()
    username = f"@{user.username}" if user.username else ""
    msg = (
        f"üëã Xin ch√†o {full_name} {username}!\n"
        "‚Ä¢ D√πng /choosehero ƒë·ªÉ ch·ªçn T∆∞·ªõng - Skin c·∫ßn mod.\n"
        "‚Ä¢ D√πng /run ƒë·ªÉ ch·∫°y mod sau khi ch·ªçn xong."
    )
    if int(user.id) == ADMIN_ID:
        msg += "\nüëë Ch√†o ADMIN!"
    update.message.reply_text(msg)

def choosehero(update: Update, context: CallbackContext):
    user = update.effective_user
    if is_blocked(user):
        update.message.reply_text("üö´ B·∫°n ƒë√£ b·ªã ch·∫∑n kh·ªèi vi·ªác s·ª≠ d·ª•ng bot.")
        return
    if not ensure_authorized(update):
        return

    load_heroes_from_list()
    if not heroes:
        update.message.reply_text("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y danh s√°ch t∆∞·ªõng/skin. H√£y t·∫°o file list.txt ƒë√∫ng ƒë·ªãnh d·∫°ng.")
        return

    # Reset hero & skin khi b·∫Øt ƒë·∫ßu ch·ªçn
    context.user_data["selected_hero"] = None
    context.user_data["selected_skins"] = []

    markup = build_keyboard(
        list(heroes.keys()), "hero", page=0, extra_back=False, user_data=context.user_data
    )
    update.message.reply_text("üß© Ch·ªçn t∆∞·ªõng:", reply_markup=markup)



def _extract_skin_id(data: str) -> str:
    """
    H·ªó tr·ª£ 2 d·∫°ng callback_data:
      - 'pick_skin::<id>'
      - 'pick_skin::<id>::<ten_skin>'
    Tr·∫£ v·ªÅ: ch·ªâ ID (chu·ªói), kh√¥ng c√≥ t√™n.
    """
    # B√≥c ph·∫ßn sau 'pick_skin::'
    try:
        # data = "pick_skin::<id>" or "pick_skin::<id>::<ten>"
        tail = data.split("::", 1)[1]           # "<id>" ho·∫∑c "<id>::<ten>"
    except IndexError:
        return ""

    # L·∫•y ƒë√∫ng ID ·ªü tr∆∞·ªõc '::' n·∫øu c√≥
    skin_id = tail.split("::", 1)[0].strip()

    # (tu·ª≥ ch·ªçn) n·∫øu b·∫°n ƒë·∫£m b·∫£o ID l√† s·ªë, c√≥ th·ªÉ l·ªçc ch·ªâ ch·ªØ s·ªë:
    # m = re.search(r"\d+", skin_id)
    # skin_id = m.group(0) if m else skin_id

    return skin_id


def button_handler(update: Update, context: CallbackContext):
    query = update.callback_query
    user = update.effective_user
    if is_blocked(user):
        query.answer()
        query.edit_message_text("üö´ B·∫°n ƒë√£ b·ªã ch·∫∑n.")
        return

    data = query.data

    # ƒêi·ªÅu h∆∞·ªõng ph√¢n trang
    if data.startswith("page::"):
        _, type_key, page_str = data.split("::", 2)
        page = int(page_str)
        if type_key == "hero":
            items = list(heroes.keys())
            markup = build_keyboard(items, "hero", page=page, extra_back=False, user_data=context.user_data)
        else:
            hero_name = context.user_data.get("selected_hero")
            items = heroes.get(hero_name, [])
            markup = build_keyboard(items, "skin", page=page, extra_back=True, user_data=context.user_data)
        query.edit_message_reply_markup(reply_markup=markup)
        query.answer()
        return

    if data == "back_main":
        markup = build_keyboard(list(heroes.keys()), "hero", page=0, extra_back=False, user_data=context.user_data)
        query.edit_message_text("üß© Ch·ªçn t∆∞·ªõng:", reply_markup=markup)
        query.answer()
        return

    # Ch·ªçn hero ‚Üí reset l·∫°i danh s√°ch skin
    if data.startswith("pick_hero::"):
        _, hero_name = data.split("::", 1)
        context.user_data["selected_hero"] = hero_name
        context.user_data["selected_skins"] = []  # reset skin c≈©
        markup = build_keyboard(heroes.get(hero_name, []), "skin", page=0, extra_back=True, user_data=context.user_data)
        query.edit_message_text(f"üéØ Ch·ªçn skin c·ªßa {hero_name}:", reply_markup=markup)
        query.answer()
        return

    # Ch·ªçn skin ‚Üí ch·ªâ l∆∞u ID (kh√¥ng l∆∞u t√™n)
    if data.startswith("pick_skin::"):
        skin_id = _extract_skin_id(data)
        if not skin_id:
            query.answer()
            query.edit_message_text("‚ùå Callback skin kh√¥ng h·ª£p l·ªá.")
            return

        # L∆∞u v√†o RAM
        sel = context.user_data.get("selected_skins", [])
        if skin_id not in sel:
            sel.append(skin_id)
            context.user_data["selected_skins"] = sel

        # L∆∞u v√†o file ri√™ng user (append n·∫øu ch∆∞a c√≥)
        user_folder = f"user_{user.id}"
        os.makedirs(user_folder, exist_ok=True)
        sel_path = os.path.join(user_folder, "selected_skin_id.txt")

        # ƒê·ªçc file hi·ªán c√≥, d·ªçn r√°c gi·ªØ m·ªói ID
        existing = []
        if os.path.exists(sel_path):
            with open(sel_path, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    # n·∫øu l·ª° c√≥ '::ten' th√¨ c·∫Øt b·ªè
                    existing.append(line.split("::", 1)[0].strip())

        # Th√™m ID m·ªõi n·∫øu ch∆∞a c√≥
        if skin_id not in existing:
            existing.append(skin_id)

        # Ghi l·∫°i s·∫°ch s·∫Ω (m·ªói d√≤ng ƒë√∫ng 1 ID)
        with open(sel_path, "w", encoding="utf-8") as f:
            f.write("\n".join(existing) + "\n")

        query.edit_message_text(
            f"‚úÖ ƒê√£ ch·ªçn skin ID: {skin_id}\n"
            f"üìå Danh s√°ch hi·ªán t·∫°i: {', '.join(existing)}\n\n"
            "‚Ä¢ Ti·∫øp t·ª•c ch·ªçn skin kh√°c ho·∫∑c /run ƒë·ªÉ ch·∫°y."
        )
        query.answer()
        return

    query.answer()
    query.edit_message_text("‚ùì Callback kh√¥ng h·ª£p l·ªá.")

def run_v_py_for_user(user_id, chat_id, bot):
    """
    Ch·∫°y script mod v√† g·ª≠i file zip k·∫øt qu·∫£.
    """
    user_folder = f"user_{user_id}"
    os.makedirs(user_folder, exist_ok=True)

    sel_path = os.path.join(user_folder, "selected_skin_id.txt")
    if not os.path.isfile(sel_path):
        with open(sel_path, "w", encoding="utf-8") as f:
            f.write("")

    cmd = [sys.executable, "v.py", user_folder]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)  # 10 ph√∫t
    except subprocess.TimeoutExpired:
        bot.send_message(chat_id, "‚ùå Qu√° th·ªùi gian ch·∫°y v.py (timeout 10 ph√∫t).")
        return

    if result.returncode != 0:
        err = result.stderr or "Kh√¥ng c√≥ th√¥ng b√°o l·ªói."
        bot.send_message(chat_id, f"‚ùå L·ªói khi ch·∫°y v.py:\n{err}")
        return

    out = result.stdout.strip()
    if out:
        if len(out) > 4000:
            log_path = os.path.join(user_folder, "log.txt")
            with open(log_path, "w", encoding="utf-8") as f:
                f.write(out)
            with open(log_path, "rb") as f:
                bot.send_document(chat_id, f, timeout=120)
            os.remove(log_path)
        else:
            bot.send_message(chat_id, f"‚ÑπÔ∏è Log:\n{out}")

    folder_path = os.path.join(user_folder, "FOLDERMOD")
    if not os.path.isdir(folder_path):
        bot.send_message(chat_id, f"‚ùå Th∆∞ m·ª•c {folder_path} kh√¥ng t·ªìn t·∫°i.")
        return

    zip_files = [f for f in os.listdir(folder_path) if f.lower().endswith(".zip")]
    if not zip_files:
        bot.send_message(chat_id, f"‚ùå Kh√¥ng t√¨m th·∫•y file zip trong {folder_path}.")
        return

    zip_path = os.path.join(folder_path, zip_files[0])
    with open(zip_path, "rb") as f:
        bot.send_document(chat_id, f, timeout=120)

    shutil.rmtree(folder_path)
    shutil.rmtree(user_folder)


def run_auto(update: Update, context: CallbackContext):
    user = update.effective_user
    if is_blocked(user):
        update.message.reply_text("üö´ B·∫°n ƒë√£ b·ªã ch·∫∑n.")
        return
    if not ensure_authorized(update):
        return

    selected = context.user_data.get("selected_skins", [])
    if not selected:
        update.message.reply_text("‚ùå B·∫°n ch∆∞a ch·ªçn skin.")
        return

    update.message.reply_text("‚è≥ ƒêang ch·∫°y mod, vui l√≤ng ƒë·ª£i‚Ä¶")

    # Ch·∫°y v.py trong thread
    def runner():
        run_v_py_for_user(user.id, update.effective_chat.id, context.bot)
        # ‚úÖ Reset l·∫°i sau khi ch·∫°y
        context.user_data["selected_skins"] = []

    thread = threading.Thread(target=runner, daemon=True)
    thread.start()

# ============================================================
#                       MAIN & HANDLERS
# ============================================================
def main():
    updater = Updater(TOKEN, use_context=True)
    dp = updater.dispatcher

    # Conversation cho /key
    key_conv = ConversationHandler(
        entry_points=[CommandHandler("key", key_command)],
        states={
            KEY_WAITING: [MessageHandler(Filters.text & ~Filters.command, key_input)]
        },
        fallbacks=[CommandHandler("cancel", key_cancel)],
        allow_reentry=True,
    )

    # L·ªánh ng∆∞·ªùi d√πng
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(key_conv)
    dp.add_handler(CommandHandler("checkkey", checkkey))
    dp.add_handler(CommandHandler("choosehero", choosehero))
    dp.add_handler(CallbackQueryHandler(button_handler))
    dp.add_handler(CommandHandler("run", run_auto))

    # L·ªánh admin
    dp.add_handler(CommandHandler("block", block_user))
    dp.add_handler(CommandHandler("unblock", unblock_user))
    dp.add_handler(CommandHandler("sendfiles", send_files))
    dp.add_handler(CommandHandler("newkey", newkey))

    # Tin nh·∫Øn r∆°i v√†o ƒë√¢y (n·∫øu c·∫ßn debug)
    # dp.add_handler(MessageHandler(Filters.text & ~Filters.command, lambda u, c: u.message.reply_text("Tin nh·∫Øn c·ªßa b·∫°n ƒë√£ nh·∫≠n.")))

    updater.start_polling()
    updater.idle()

if __name__ == "__main__":
    main()